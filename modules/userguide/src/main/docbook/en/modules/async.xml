<chapter id="ch_asynchronouscontinuations">
  <title>Asynchronous continuations</title>

  <section id="asynchronouscontinuations">
    <title>The concept</title>

    <para>jBPM is based on Graph Oriented Programming (GOP).  Basically, GOP specifies a 
      simple state machine that can handle concurrent paths of execution.  But in the execution 
      algorithm specified in GOP, all state transitions are done in a single operation in the 
      thread of the client.
      By default, this 
      performing state transitions in the thread of the client is a good approach cause it fits 
      naturally with server side transactions.  The process execution moves from one wait state 
      to another wait state in one transaction.  
    </para>

    <para>But in some situations, a developer might want to fine-tune the transaction 
      demarcation in the process definition.  In jPDL, it is possible to specify that the process 
      execution should continue asynchronously with the attribute <literal>async=&quot;true&quot;</literal>.  
      <literal>async=&quot;true&quot;</literal> can be specified on all node types and all action types.  
    </para>
    
  </section>
  <section id="asynchronousexample">
    <title>An example</title>
  
    <para>Normally, a node is always executed after a token has entered the node.  So the node is 
      executed in the thread of the client.  We'll explore asynchronous continuations by looking 
      two examples.  The first example is a part of a process with 3 nodes.  Node 'a' is a wait 
      state, node 'b' is an automated step and node 'c' is again a wait state.  This process does 
      not contain any asynchronous behavior and it is represented in the picture below.
    </para>
  
    <para>The first frame, shows the starting situation.  The token points to node 'a', meaning 
      that the path of execution is waiting for an external trigger.  That trigger must be given 
      by sending a signal to the token.  When the signal arrives, the token will be passed from 
      node 'a' over the transition to node 'b'.  After the token arrived in node 'b', node 'b' 
      is executed.  Recall that node 'b' is an automated step that does not behave as a wait 
      state (e.g. sending an email).  So the second frame is a snapshot taken when node 'b' is 
      being executed.  Since node 'b' is an automated step in the process, the execute of node 
      'b' will include the propagation of the token over the transition to node 'c'.  Node 'c'
      is a wait state so the third frame shows the final situation after the signal method 
      returns.
    </para>

    <figure id="async1.image">
      <title>Example 1: Process without asynchronous continuation</title>
      <mediaobject><imageobject><imagedata align="center" fileref="images/async1.gif"/></imageobject></mediaobject>
    </figure>
    
    <para>While persistence is not mandatory in jBPM, the most common scenario is that a signal 
      is called within a transaction.  Let's have a look at the updates of that transaction.  
      First of all, the token is updated to point to node 'c'.  These updates are generated by 
      hibernate as a result of the <literal>GraphSession.saveProcessInstance</literal> on a 
      JDBC connection.  Second, in case the automated action would access and update some 
      transactional resources, those transactional updates should be combined or part of 
      the same transaction.
    </para>
  
    <para>Now, we are going to look at the second example, the second example is a variant of 
      the first example and introduces an asynchronous continuation in node 'b'.  Nodes 'a' and 
      'c' behave the same as in the first example, namely they behave as wait states.  In jPDL,
      a node is marked as asynchronous by setting the attribute <literal>async=&quot;true&quot;</literal>.
    </para>
  
    <para>The result of adding <literal>async=&quot;true&quot;</literal> to node 'b' is that the process 
      execution will be split up into 2 parts.  The first part will execute the process up to 
      the point where node 'b' is to be executed.  The second part will execute node 'b' and 
      that execution will stop in wait state 'c'.
    </para>
    
    <para>The transaction will hence be split up into 2 separate transactions.  One transaction 
      for each part.  While it requires an external trigger (the invocation of the 
      <literal>Token.signal</literal> method) to leave node 'a' in the first transaction, jBPM 
      will automatically trigger and perform the second transaction.
    </para>

    <figure id="asynchronous.continuations.image">
      <title>Example 2: A process with asynchronous continuations</title>
      <mediaobject><imageobject><imagedata align="center" fileref="images/asynchronous.continuations.gif"/></imageobject></mediaobject>
    </figure>

    <para>For actions, the principle is similar.  Actions that are marked with the 
      attribute <literal>async=&quot;true&quot;</literal> are executed outside of the thread that 
      executes the process.  If persistence is configured (it is by default), the actions 
      will be executed in a separate transaction.
    </para>

    <para>In jBPM, asynchronous continuations are realized by using an asynchronous messaging 
      system.  When the process execution arrives at a point that should be executed 
      asynchronously, jBPM will suspend the execution, produces a command message and send it 
      to the command executor. The command executor is a separate component that, upon receipt 
      of a message, will resume the execution of the process where it got suspended.
    </para>

    <para>jBPM can be configured to use a JMS provider or its built-in asynchronous messaging
      system.  The built-in messaging system is quite limited in functionality, but allows 
      this feature to be supported on environments where JMS is unavailable.
    </para>
    
  </section>
  <section id="thejobexecutor">
    <title>The job executor</title>
    
    <para>The job executor is the component that resumes process executions asynchronously.
      It waits for job messages to arrive over an asynchronous messaging system and executes 
      them.  The two job messages used for asynchronous continuations are 
      <literal>ExecuteNodeJob</literal> and <literal>ExecuteActionJob</literal>.
    </para>

    <para>These job messages are produced by the process execution.  During process execution, 
      for each node or action that has to be executed asynchronously, a <literal>Job</literal>
      (POJO) will be dispatched to the <literal>MessageService</literal>.  The message service 
      is associated with the <literal>JbpmContext</literal> and it just collects all the 
      messages that have to be sent.
    </para>
    
    <para>The messages will be sent as part of <literal>JbpmContext.close()</literal>.
      That method cascades the <literal>close()</literal> invocation 
      to all of the associated services.  The actual services can be configured in 
      <literal>jbpm.cfg.xml</literal>.  One of the services, <literal>DbMessageService</literal>, is 
      configured by default and will notify the job executor that new job messages are available.
    </para>

    <para>The graph execution mechanism uses the interfaces 
      <literal>MessageServiceFactory</literal> and <literal>MessageService</literal> to 
      send messages.  This is to make the asynchronous messaging service 
      configurable (also in <literal>jbpm.cfg.xml</literal>). In Java EE environments, the 
      <literal>DbMessageService</literal> can be replaced with the <literal>JmsMessageService</literal>
      to leverage the application server's capabilities.
    </para>
    
    <para>Here's how the job executor works in a nutshell:
    </para>
    
    <para>Jobs are records in the database.  Jobs are objects and can be executed, too.  Both timers 
    and asynchronous messages are jobs. For asynchronous messages, the dueDate is simply set to now when they 
    are inserted.  The job executor must execute the jobs.  This is done in 2 phases: 1) a job 
    executor thread must acquire a job and 2) the thread that acquired the job must execute it.  
    </para>
    
    <para>Acquiring a job and executing the job are done in 2 separate transactions.  A thread 
    acquires a job by putting its name into the owner field of the job.  Each thread has a unique 
    name based on ip-address and sequence number.  Hibernate's optimistic locking is enabled on 
    <literal>Job</literal>-objects.  So if 2 threads try to acquire a job concurrently, one of 
    them will get a StaleObjectException and rollback.  Only the first one will succeed.  The 
    thread that succeeds in acquiring a job is now responsible for executing it in a separate 
    transaction.
    </para>

    <para>A thread could die between acquisition and execution of a job.  To clean-up after 
    those situations, there is one lock-monitor thread per job executor that checks the lock times.  
    The lock monitor thread will unlock any jobs that have been locked for more than 30 minutes,
    so that they can be executed by another job executor thread.
    </para>

    <para>The required isolation level should be set to REPEATABLE_READ for Hibernate's optimistic 
    locking to work correctly.  That isolation level will guarantee that 
    </para>

    <programlisting>update JBPM_JOB job
set job.version = 2
    job.lockOwner = '192.168.1.3:2'
where 
    job.version = 1</programlisting>

    <para>will only result in 1 row updated in exactly 1 of the competing transactions.
    </para>
  
    <para>Non-Repeatable Reads means that the following anomaly can happen: A transaction reads 
    previously read data again and finds that data has been modified by another transaction, one 
    that has been committed since the transaction's previous read.
    </para>
    
    <para>Non-Repeatable reads are a problem for optimistic locking. Therefore, isolation level 
    READ_COMMITTED is not enough, as it allows for Non-Repeatable reads to occur.  So 
    REPEATABLE_READ is required if you configure more than one job executor thread.
    </para>
  </section>

  <section id="jbpmsbuiltinasynchronousmessaging">
    <title>jBPM's built-in asynchronous messaging</title>
    <para>When using jBPM's built-in asynchronous messaging, job messages will be sent by persisting 
      them to the database.  This message persisting can be done in the same transaction/JDBC 
      connection as the jBPM process updates.
    </para>
    <para>The job messages will be stored in the <literal>JBPM_JOB</literal> table.
    </para>
    <para>The POJO command executor (<literal>org.jbpm.msg.command.CommandExecutor</literal>)
      will read the messages from the database table and execute them.  So the typical 
      transaction of the POJO command executor looks like this: 1) read next command message
      2) execute command message 3) delete command message.
    </para>
    <para>If execution of a command message fails, the transaction will be rolled back.
      After that, a new transaction will be started that adds the error message to the 
      message in the database.  The command executor filters out all messages that contain
      an exception.
    </para>
    <figure id="pojo.command.executor.image">
      <title>POJO command executor transactions</title>
      <mediaobject><imageobject><imagedata align="center" fileref="images/pojo.command.executor.gif"/></imageobject></mediaobject>
    </figure>
    <para>If for some reason or another, the transaction that adds the exception to the 
      command message would fail, it is rolled back as well.  In that case, the 
      message remains in the queue without an exception so it will be retried later.
    </para>
    <para>Limitation: beware that jBPM's built-in asynchronous messaging system does 
      not support multi-node locking.  So you cannot just deploy the POJO command 
      executor multiple times and have them configured to use the same database.
    </para>
  </section>

</chapter>
